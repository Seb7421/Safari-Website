---
import { getLangFromUrl, useTranslations, useTranslatedPath } from "@i18n/utils";

const { class: className } = Astro.props;

const lang = getLangFromUrl(Astro.url);
const t = useTranslations(lang);
const translatePath = useTranslatedPath(lang);
---

<!-- The best thing? It's all in one -->
<div id="smooth-wrapper" class:list={["section tagline-section relative bg-zinc-900 text-white", className]}>
	<div class="tagline-arrows">
		<svg
			stroke-linecap="round"
			class="h-[15rem] w-[15rem] rotate-45 md:w-[20rem] md:rotate-0 lg:w-[25rem]"
			stroke-linejoin="round"
			viewBox="0 0 550 330">
			<path
				id="tagline-arrow-path"
				fill="none"
				stroke="#fff"
				stroke-width="10"
				d="M8.5,7.8C46.3,67,121.7,185.5,265.5,185.9c42.8,0.1,120.5-55.9-25.2-120.3
	C79-5.8,177.6,164.1,222.3,207.7c59.1,49.9,83.8,62.1,162.6,96.8">
			</path>
			<path class="opacity-0" id="tagline-arrow" stroke="white" stroke-width="12" d="M465.7 172.9l47.1 6-29.8 33.3-17.3-39.3z"></path>
		</svg>
	</div>
	<div class="text col-span-12 flex justify-center font-light">
		<p id="services-tagline" class="max-w-5xl text-center text-4xl md:text-5xl lg:text-7xl">
			{t("tagline")}
		</p>
	</div>
</div>

<style>
        .text > p > :global(div) {
                background: linear-gradient(to right, rgb(255, 255, 255) 50%, rgb(37, 37, 37) 50%);
                background-size: 200% 100%;
                background-position-x: 100%;
                color: transparent;
                background-clip: text;
                -webkit-background-clip: text;
                line-height: 1.2;
        }
        #tagline-arrow {
                opacity: 0;
                transform-box: fill-box;
                transform-origin: center;
        }
</style>

<script>
        import { gsap } from "gsap";
        import { ScrollTrigger } from "gsap/ScrollTrigger";

        gsap.registerPlugin(ScrollTrigger);

        function init() {
                const linePath = document.querySelector("#tagline-arrow-path");
                const arrow = document.querySelector("#tagline-arrow");

                if (linePath instanceof SVGPathElement) {
                        const totalLength = linePath.getTotalLength();
                        linePath.style.strokeDasharray = `${totalLength}`;
                        linePath.style.strokeDashoffset = `${totalLength}`;

                        const arrowTimeline = gsap.timeline({
                                scrollTrigger: {
                                        trigger: ".tagline-arrows",
                                        start: "center bottom",
                                        end: "center center",
                                        markers: false,
                                        scrub: 1,
                                },
                        });

                        arrowTimeline.to(linePath, { strokeDashoffset: 0, ease: "none" }, 0);

                        if (arrow instanceof SVGPathElement) {
                                const arrowBox = arrow.getBBox();
                                const offsetX = arrowBox.x + arrowBox.width / 2;
                                const offsetY = arrowBox.y + arrowBox.height / 2;

                                arrowTimeline.eventCallback("onUpdate", () => {
                                        const progress = arrowTimeline.progress();
                                        const currentLength = totalLength * progress;
                                        const clampedLength = Math.max(0, Math.min(totalLength, currentLength));
                                        const point = linePath.getPointAtLength(clampedLength);
                                        const lookAhead = Math.min(totalLength, clampedLength + 1);
                                        const nextPoint = linePath.getPointAtLength(lookAhead);
                                        const angle = Math.atan2(nextPoint.y - point.y, nextPoint.x - point.x) * (180 / Math.PI);

                                        arrow.style.opacity = progress > 0 ? "1" : "0";
                                        arrow.style.transformBox = "fill-box";
                                        arrow.style.transformOrigin = "center";
                                        arrow.style.transform = `translate(${point.x - offsetX}px, ${point.y - offsetY}px) rotate(${angle}deg)`;
                                });
                        }
                }

                const tagline = document.querySelector("#services-tagline");
                if (tagline) {
                        gsap.to(tagline, {
                                backgroundPositionX: 0,
                                ease: "none",
                                scrollTrigger: {
                                        trigger: tagline,
                                        markers: false,
                                        scrub: 1,
                                        start: "top bottom-=20%",
                                        end: "bottom bottom-=10%",
                                },
                        });
                }
        }

	document.removeEventListener("DOMContentLoaded", init); // astro:page-load
	document.addEventListener("DOMContentLoaded", init); // astro:page-load
</script>
